# -*- coding: utf-8 -*-
"""Milestone2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14r8bBA4gzDswNQ_rfbeUqAG35-w42nFk
"""

import ast
import json
import math
import pandas as pd
from radon.metrics import mi_visit


class PythonQualityChecker(ast.NodeVisitor):
    def __init__(self, source_code):
        self.source_code = source_code
        self.tree = ast.parse(source_code)
        self.issues_found = []
        self.lines_of_code = len(source_code.splitlines())
        self.decision_points = 0

    # -------- Rule Definitions --------

    def visit_FunctionDef(self, node):
        # Rule 1: Missing Docstring
        if ast.get_docstring(node) is None:
            self.issues_found.append({
                "problem": "Function without Docstring",
                "severity": "MEDIUM",
                "line": node.lineno
            })

        # Rule 2: Large Function
        if len(node.body) > 18:
            self.issues_found.append({
                "problem": "Large Function Block",
                "severity": "HIGH",
                "line": node.lineno
            })

        # Rule 3: Too Many Parameters
        if len(node.args.args) > 4:
            self.issues_found.append({
                "problem": "Excessive Parameters",
                "severity": "MEDIUM",
                "line": node.lineno
            })

        self.generic_visit(node)

    # -------- Complexity Tracking --------

    def visit_If(self, node):
        self.decision_points += 1
        self.generic_visit(node)

    def visit_For(self, node):
        self.decision_points += 1
        self.generic_visit(node)

    def visit_While(self, node):
        self.decision_points += 1
        self.generic_visit(node)

    # -------- Metrics --------

    def cyclomatic_complexity(self):
        return self.decision_points + 1

    def maintainability_index(self):
        return round(mi_visit(self.source_code, False), 2)

    def quality_score(self):
        score = 100
        for item in self.issues_found:
            if item["severity"] == "HIGH":
                score -= 12
            elif item["severity"] == "MEDIUM":
                score -= 6
        return max(score, 0)


    def generate_report(self, file_name):
        return {
            "file_name": file_name,
            "lines_of_code": self.lines_of_code,
            "cyclomatic_complexity": self.cyclomatic_complexity(),
            "maintainability_index": self.maintainability_index(),
            "quality_score": self.quality_score(),
            "issues": self.issues_found
        }



def analyze_project(codebase):
    reports = []

    for fname, code in codebase.items():
        checker = PythonQualityChecker(code)
        checker.visit(checker.tree)
        reports.append(checker.generate_report(fname))

    return reports


def project_statistics(reports):
    return {
        "average_quality_score": round(
            sum(r["quality_score"] for r in reports) / len(reports), 2),
        "average_maintainability_index": round(
            sum(r["maintainability_index"] for r in reports) / len(reports), 2)
    }


def export_json(data):
    with open("project_quality.json", "w") as f:
        json.dump(data, f, indent=4)


def export_csv(data):
    df = pd.DataFrame(data)
    df.to_csv("project_quality.csv", index=False)



if __name__ == "__main__":

    source_files = {
        "math_ops.py": """
def multiply(x, y):
    return x * y
""",
        "data_handler.py": """
def handle_data(data, a, b, c, d):
    for value in data:
        if value > 50:
            print(value)
"""
    }

    file_reports = analyze_project(source_files)
    summary = project_statistics(file_reports)

    export_json(file_reports)
    export_csv(file_reports)

    print("File Level Report:")
    print(file_reports)

    print("\\nProject Summary:")
    print(summary)